<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-07-24T12:51:51+05:30</updated><id>/feed.xml</id><title type="html">blank</title><subtitle>Personal webpage of Ashutosh Sathe 
</subtitle><entry><title type="html">Parsing the parser</title><link href="/blog/2021/parsing-the-parser/" rel="alternate" type="text/html" title="Parsing the parser" /><published>2021-04-01T08:44:59+05:30</published><updated>2021-04-01T08:44:59+05:30</updated><id>/blog/2021/parsing-the-parser</id><content type="html" xml:base="/blog/2021/parsing-the-parser/">&lt;p&gt;This blog is about my project called &lt;a href=&quot;https://github.com/ashutoshbsathe/yacv&quot;&gt;yacv&lt;/a&gt;. If you have no idea what that is, you should watch the &lt;a href=&quot;https://www.youtube.com/watch?v=BozB0O0__Qg&quot;&gt;video&lt;/a&gt;. In this blog I go through:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Why I find parsing interesting&lt;/li&gt;
  &lt;li&gt;Why I find parser generators to be amusing&lt;/li&gt;
  &lt;li&gt;Why and how I built &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yacv&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Interesting facts and references about parsers. You can &lt;a href=&quot;#interesting-reads&quot;&gt;skip down to this part&lt;/a&gt; directly&lt;/li&gt;
&lt;/ol&gt;

&lt;center&gt;
&lt;img src=&quot;/files/blog_assets/parsing-the-parser/dict_meaning.png&quot; alt=&quot;dictionary meaning of parsing&quot; width=&quot;100%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;Parsing is a very fundamental process in computer science. It comes up pretty much everywhere in computer science – be it writing a simple command line program (which accepts and hence “parses” command line arguments) or be it building a complicated client server architecture (which will most likely use message passing and hence will need “parsing” the message)&lt;/p&gt;

&lt;h2 id=&quot;parsing-is-awesome&quot;&gt;Parsing is awesome&lt;/h2&gt;
&lt;p&gt;At my college, parsing is taught in compiler construction class – in the very final semester of the degree. Because of this I wasn’t getting any theory (as in theoretical CS) related stuff in the very awesome &lt;a href=&quot;https://suif.stanford.edu/dragonbook/&quot;&gt;“dragon book”&lt;/a&gt;. Due to COVID lockdown, I finally got time to revise theoretical CS again. After revision, I was just amazed how powerful the concepts in theoretical CS can be. I was also flabbergasted by the importance of parsing&lt;/p&gt;

&lt;p&gt;The heart of “compiling a program” is parsing – in a way, once you have the parse tree, you’re “pretty much” done !&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Once you get the parse tree, you’re sure that this program was syntactically correct (user hasn’t inputted a Python code into a C compiler)&lt;/li&gt;
  &lt;li&gt;Using the syntax tree, you can VERY EASILY identify semantic errors (without a syntax tree, this is a guaranteed nightmare)&lt;/li&gt;
  &lt;li&gt;Syntax directed translation can generate machine code for you ! (granted this code won’t be optimized in the slightest)&lt;/li&gt;
  &lt;li&gt;Code optimization heavily relies on several structures and properties of syntax trees&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I mean ofcourse, it makes sense. There’s a reason parsing is in the first few steps of compilation pipeline. But I finally had the “aha, this makes so much sense” moment so I had to write it here. The entire compiling process is in a weird-way “just” parsing. You can just have syntax directed translation to generate you machine code which works ! Ofcourse, such a code will not have any safety checks or optimization whatsoever, but in theory it just works !! How cool is that !!!&lt;/p&gt;

&lt;p&gt;In reality though, many people (including myself) would care about (boring) things like memory safety and (cool) things like code optimizations. But still, even then, you’re just adding things on top of parsing to make things better&lt;/p&gt;

&lt;h2 id=&quot;why-do-parser-generators-exist-&quot;&gt;Why do parser generators exist ?&lt;/h2&gt;
&lt;p&gt;Building a parser is no easy task. Making sure that parser works correctly for ALL the strings that can be possibly be input to the parser is a tricky task. For finite languages, this is very easy as we simply try all the possible strings in the language with the parser and verify that parser outputs “yes” for all the strings in the language&lt;/p&gt;

&lt;p&gt;On infinite languages i.e. most practical languages, this is impossible to do for obvious reasons. On the other hand, if we use some properties of formal languages, we can automatically generate the parser which will be guaranteed to work&lt;/p&gt;

&lt;p&gt;Let’s take an example language \(L = a^nb^n\). If we were to write a parser for this in C, it would look something like this :&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_valid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* String `s` with length `n` */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;a&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* At this i, s[i] != &apos;a&apos; and count = count(a) */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;b&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It will work and because the language is so easy to understand, we can easily verify if this parser will work correctly or not. But in case of practical languages, this is often an impossible task to do so. So how can we make sure that our parser works correctly for all strings in a language ?&lt;/p&gt;

&lt;p&gt;To be sure about this, we must know all the possible prefixes of strings in a language. A parser algorithm can then just read the string one by one and make sure the prefix (i.e. string read so far) belongs to one of the possible prefixes. If at any time, this string is NOT a possible prefix, we quit and say “invalid string”. Formally, these prefixes are referred to as “viable prefixes”&lt;/p&gt;

&lt;p&gt;But then, we have just moved the problem from “knowing all the strings” to “knowing all the prefixes”. &lt;strong&gt;Thankfully, for context free languages, language formed by all the prefixes of that language is a regular language.&lt;/strong&gt; This means that we can generate a regular i.e. finite automata for identifying viable prefixes of a language. This is precisely what a parser generator does – it generates the automaton of viable prefixes given the context free grammar and uses it to “parse” the input string. This regularity in prefixes is also the reason why parser generators exist &lt;em&gt;only&lt;/em&gt; for context free languages !&lt;/p&gt;

&lt;p&gt;(BTW, the approach I’m discussing here is called “bottom up parsing” and the specific algorithm is called “LR parsing” – which was presented by Donald Knuth. There is also an approach called “bottom up parsing” but it does not allow very interesting parser “generators” so I’m skipping that here)&lt;/p&gt;

&lt;h2 id=&quot;key-takeaways&quot;&gt;Key takeaways&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Parsers are awesome !&lt;/li&gt;
  &lt;li&gt;Parsers (often) rely on finding viable prefixes&lt;/li&gt;
  &lt;li&gt;Writing and testing parsers can be very difficult&lt;/li&gt;
  &lt;li&gt;Parser generators can generate a parser that works perfectly for a given grammar&lt;/li&gt;
  &lt;li&gt;Parser generators exist only for context free grammars because prefixes of only context free languages form a regular language&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;yacv-yet-another-compiler-visualizer&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yacv&lt;/code&gt;: Yet Another Compiler Visualizer&lt;/h2&gt;

&lt;p&gt;All the hardwork I had to go through to understand parsers made me realize that there are going to be tons of people like me around. What made parsers “click” to me was this amazing &lt;a href=&quot;https://www.cs.princeton.edu/courses/archive/spring20/cos320/LR0/&quot;&gt;LR(0) parser visualization by Zak Kincaid and Shaowei Zhu&lt;/a&gt; which walks you through the parsing process step-by-step. Other tools such as &lt;a href=&quot;http://jsmachines.sourceforge.net/machines/lr1.html&quot;&gt;JSMachines&lt;/a&gt; also helped. But none of these tools produced output which was “presentable” (i.e. can be put in presentation) So I wrote a small tool that visualizes parsing procedure using &lt;a href=&quot;https://github.com/3b1b/manim&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;manim&lt;/code&gt;&lt;/a&gt; – an animation library by &lt;a href=&quot;https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw&quot;&gt;3Blue1Brown&lt;/a&gt;. The name &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yacv&lt;/code&gt; is inspired from old parser generator software called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yacc&lt;/code&gt; (Yet Another Compiler Compiler)&lt;/p&gt;

&lt;h3 id=&quot;approach&quot;&gt;Approach&lt;/h3&gt;
&lt;p&gt;Typical parsers (like LR and LL) read input stream one character at a time and keep building a partial parse tree until the input stream ends. At the end, the parse tree is (hopefully) complete and can be used further. In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yacv&lt;/code&gt;, I progressively build a simple python \(n\)-ary tree structure as I am parsing. Later I use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GraphViz&lt;/code&gt; to lay out the tree visually. This simplifies the programming and enables me to add as many parsers as I want to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yacv&lt;/code&gt;&lt;/p&gt;

&lt;center&gt;
    &lt;a href=&quot;https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW0NvbnRleHQgRnJlZSBHcmFtbWFyIC0gR10gLS0-IEJbUGFyc2VyXVxuICAgIENbSW5wdXQgU3RyaW5nIC0gc10gLS0-IEJbUGFyc2VyXVxuICAgIEIgLS0-IHxQYXJzZSBUcmVlfCBEW0dyYXBodml6IENvbnZlcnRlcl1cbiAgICBEIC0tPiB8R3JhcGh2aXogR3JhcGh8IEVbTWFuaW0gRnJhbWVdIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0&quot;&gt;&lt;img src=&quot;https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW0NvbnRleHQgRnJlZSBHcmFtbWFyIC0gR10gLS0-IEJbUGFyc2VyXVxuICAgIENbSW5wdXQgU3RyaW5nIC0gc10gLS0-IEJbUGFyc2VyXVxuICAgIEIgLS0-IHxQYXJzZSBUcmVlfCBEW0dyYXBodml6IENvbnZlcnRlcl1cbiAgICBEIC0tPiB8R3JhcGh2aXogR3JhcGh8IEVbTWFuaW0gRnJhbWVdIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0&quot; alt=&quot;flow diagram of yacv&quot; width=&quot;100%&quot; /&gt;&lt;/a&gt;
&lt;/center&gt;

&lt;h3 id=&quot;graphviz-conversion&quot;&gt;Graphviz Conversion&lt;/h3&gt;
&lt;p&gt;Converting the abstract syntax tree to graphviz graph was simple. Just creating the graph with the specification was simple enough. But that graph did not look “nice” for 2 reasons:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The leaf nodes i.e. the terminals in the string were on various different levels&lt;/li&gt;
  &lt;li&gt;Nodes on the RHS of the production weren’t on the same level&lt;/li&gt;
  &lt;li&gt;All productions looked the same color&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
    &lt;thead&gt;
    &lt;tr&gt;
        &lt;th&gt; Before &lt;/th&gt;
        &lt;th&gt; After &lt;/th&gt;
    &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
    &lt;td&gt;&lt;img src=&quot;data:image/png;base64,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&quot; width=&quot;100%&quot; /&gt;&lt;/td&gt;
    &lt;td&gt;&lt;img src=&quot;/files/blog_assets/parsing-the-parser/ast-simple-cd-grammar.png&quot; width=&quot;100%&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To get this transformation, I had to &lt;a href=&quot;https://github.com/ashutoshbsathe/yacv/blob/a695164016a91fca9205bb237ed5087c3e6a2b93/yacv/abstractsyntaxtree.py#L4&quot;&gt;store the production number at every node of the tree&lt;/a&gt; and use &lt;a href=&quot;https://github.com/ashutoshbsathe/yacv/blob/a695164016a91fca9205bb237ed5087c3e6a2b93/yacv/mobjects.py#L180&quot;&gt;a lot of “rank hacks” in graphviz&lt;/a&gt;. Storing production ID at every node is a bit awkward because then you have to maintain some order of the productions. I figured the order in which they are present in the input file was the best. Then we can simply map production ID to a color (which is also customizable by user). I used &lt;a href=&quot;https://pygraphviz.github.io/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pygraphviz&lt;/code&gt;&lt;/a&gt; for doing all the GraphViz stuff. It provides good enough control on the GraphViz graph you are creating despite being just a SWIG wrapper. One of the most valuable function for me was the &lt;a href=&quot;https://pygraphviz.github.io/documentation/stable/reference/agraph.html?highlight=layout#pygraphviz.AGraph.layout&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;layout&lt;/code&gt;&lt;/a&gt; function. Layout function will hardcode the position of each and every node using the specified rendering algorithm. This simplified interfacing with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;manim&lt;/code&gt; a lot&lt;/p&gt;

&lt;h3 id=&quot;putting-everything-in-a-manim-frame&quot;&gt;Putting everything in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;manim&lt;/code&gt; frame&lt;/h3&gt;
&lt;p&gt;This has to be the most frustrating part of the project. First, there is no reliable documentation for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;manim&lt;/code&gt; whatsoever. There are 2 versions of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;manim&lt;/code&gt; – a community version called ManimCE and original version (by 3b1b) which uses OpenGL now. I had used manim once or twice before starting this project but not so much that I knew everything in and out. Thankfully, there is a series of &lt;a href=&quot;https://www.youtube.com/playlist?list=PL2B6OzTsMUrwo4hA3BBfS7ZR34K361Z8F&quot;&gt;excellent tutorial videos&lt;/a&gt; on YouTube channel called &lt;a href=&quot;https://www.youtube.com/c/TheoremofBeethoven&quot;&gt;Theorem of Beethoven&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The TL:DR of the tutorial was that everything in Manim is managed on a 14x8 grid. This meant that I had to resize my GraphViz graph to fit into 14x8 grid. Thankfully, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;layout()&lt;/code&gt; calculates the coordinates of each and every node so positioning nodes on the manim grid wasn’t a problem at all&lt;/p&gt;

&lt;p&gt;About edges, GraphViz stores every edge as a &lt;a href=&quot;https://en.wikipedia.org/wiki/ B%C3%A9zier_curve&quot;&gt;Bézier curve&lt;/a&gt; (makes sense because GraphViz often renders to SVG). Finding this information took a lot of digging through GraphViz code, but it was worth it because I learned a lot about SVG and Bézier curves. Storing a Bézier curve usually means storing the control points, then at the time of rasterization, we can render \(n\) points on the curve using these control points. To put them in manim, I decided to render fixed \(n=100\) points on every edge in their original coordinates and then rescaled every point down to 14x8. Then using this list of points, I used a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VMobject&lt;/code&gt; from manim and used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_points_smoothly&lt;/code&gt; method to add all these points into that object. All of this implementation is tied together in a new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mobject&lt;/code&gt; class called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GraphvizMobject&lt;/code&gt; code for which is available &lt;a href=&quot;https://github.com/ashutoshbsathe/yacv/blob/a695164016a91fca9205bb237ed5087c3e6a2b93/yacv/mobjects.py#L16&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;animating-between-steps&quot;&gt;Animating between steps&lt;/h3&gt;

&lt;p&gt;Using simple manim transform on every node and edge wasn’t enough. It looked awkward with nodes flying everywhere&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;/files/blog_assets/parsing-the-parser/awakward-animation.gif&quot; alt=&quot;rajatvd/manimnx demo&quot; width=&quot;100%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;To make the animations smoother, I had to relabel the GraphViz graph carefully, then map every node ID from GraphViz graph to an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mobject&lt;/code&gt; and then while transforming, use the node IDs to smooth the animations. The &lt;a href=&quot;https://github.com/ashutoshbsathe/yacv/blob/a695164016a91fca9205bb237ed5087c3e6a2b93/yacv/mobjects.py#L123&quot;&gt;code for the animation&lt;/a&gt; speaks for itself better than I can&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;/files/blog_assets/parsing-the-parser/smooth-animation.gif&quot; alt=&quot;amooth animation demo&quot; width=&quot;100%&quot; /&gt;
&lt;/center&gt;

&lt;h3 id=&quot;final-outcome&quot;&gt;Final outcome&lt;/h3&gt;

&lt;p&gt;After the key components were working nicely together, I decided to sweeten the animation by adding visualization for the parsing stack as well. This was significantly easier than GraphViz although it needed some neat little tricks as well. Main obstacle in animating this was the size of stack during parsing. It is completely possible that stack contains 100s of elements during parsing at a time and it was very difficult to animate this. So I had two options when implementing stack animations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Resize every element in stack once new element is added (so essentially font size of character decreases to accommodate new stack elements)&lt;/li&gt;
  &lt;li&gt;Show only top-\(k\) stack elements and then show “\(\dots\)” at the end to indicate more elements are present&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I went with the second option because it looked clean and I didn’t have to worry about dynamically resizing every single element in the stack. Animating these stack states was a cakewalk after animating &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GraphvizMobject&lt;/code&gt;s&lt;/p&gt;

&lt;p&gt;Finally, I decided to package everything in a nice python package so everyone can access it without worrying about the implementation. This project was an insane rollercoaster ride. I doubted my tool choices at many times, I doubted in myself many times but at the end it was a really good learning experience. Check out yacv on &lt;a href=&quot;https://github.com/ashutoshbsathe/yacv&quot;&gt;GitHub&lt;/a&gt; or read the &lt;a href=&quot;https://ashutoshbsathe.github.io/yacv&quot;&gt;docs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;interesting-reads&quot;&gt;Interesting reads&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/Parsing-Techniques-Monographs-Computer-Science/dp/038720248X/ref=sr_11_1?ie=UTF8&amp;amp;qid=1197794717&amp;amp;sr=11-1&quot;&gt;Awesome book on parsing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/6319086/are-gcc-and-clang-parsers-really-handwritten&quot;&gt;GCC and Clang use handwritten parsers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/14589567/7914234&quot;&gt;Parsing C++ is (probably) Turing-complete&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.reverberate.org/2013/09/ll-and-lr-in-context-why-parsing-tools.html&quot;&gt;Why parsing tools are hard&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://craftinginterpreters.com/&quot;&gt;A good, free book for interpreters&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">This blog is about my project called yacv. If you have no idea what that is, you should watch the video. In this blog I go through: Why I find parsing interesting Why I find parser generators to be amusing Why and how I built yacv Interesting facts and references about parsers. You can skip down to this part directly</summary></entry><entry><title type="html">Building neural nets in Minecraft</title><link href="/blog/2020/minecraft-neural-nets/" rel="alternate" type="text/html" title="Building neural nets in Minecraft" /><published>2020-05-06T01:35:05+05:30</published><updated>2020-05-06T01:35:05+05:30</updated><id>/blog/2020/minecraft-neural-nets</id><content type="html" xml:base="/blog/2020/minecraft-neural-nets/">&lt;p&gt;This blog explains my thoughts behind creation of my project called &lt;a href=&quot;https://github.com/ashutoshbsathe/scarpet-nn&quot;&gt;scarpet-nn&lt;/a&gt; which allows you to implement binarized neural nets in Minecraft.&lt;/p&gt;

&lt;p&gt;I think neural network in Minecraft is a cool idea because it opens us to so many new possibilities in-game. Think of custom maps where mapmakers can hide a secret passage or rooms which are accessible only when you draw certain pattern on a wall and the in-game neural network recognizing it ! We can have games where each stage completion computes output of a layer of your neural network and so if you complete the  stages in wrong order, you obviously get wrong answers. We can have a multiplayer game where one team modifies the neural network activations to change the output of neural network while the other team changes the weights of the neural network to make sure output does not change. More than this, I think just visualizing the neural network calculating results block by block in Minecraft would be very satisfying to watch too !&lt;/p&gt;

&lt;h2 id=&quot;am-i-the-first-to-think-of-this-&quot;&gt;Am I the first to think of this ?&lt;/h2&gt;

&lt;p&gt;No, ofcourse not. &lt;em&gt;There’s always someone who has thought of the same thing before you (ALWAYS)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;On some quick googling, I found an implementation of an &lt;a href=&quot;https://www.reddit.com/r/Minecraft/comments/ak22ur/neural_network_for_handwritten_digit_recognition/&quot;&gt;MNIST ConvNet in Minecraft&lt;/a&gt;. It was decently fast, but required a ton of memory, wasn’t server friendly at all and used more than 2 million (!!!) command blocks to implement it. This meant that if some custom map creator wanted to use this in their server, they would need compute comparable to a dedicated data center to run the server smoothly. Moreover, it also doesn’t offer us flexibility to reconfigure the neural network, which means if you wanted to implement some new neural network, you would need to rewrite/regenerate all those millions of command blocks. Plus, there is no nice block-by-block visualization possibilities in this.&lt;/p&gt;

&lt;h2 id=&quot;design&quot;&gt;Design&lt;/h2&gt;

&lt;p&gt;I decided to limit my scope for implementing only conv and fully connected layers (for now). These layers are easy to implement since they only need multiplication and addition operations. My initial idea was to take a CPU designed in Minecraft (such as this &lt;a href=&quot;https://www.youtube.com/watch?v=5Fwy4jUJUoM&quot;&gt;amazing 32 bit FPU&lt;/a&gt;), take a memory designed in Minecraft (like &lt;a href=&quot;https://www.youtube.com/watch?v=7NaWSnlcr8w&quot;&gt;this video&lt;/a&gt;), connect them using some redstone &lt;em&gt;magic&lt;/em&gt; and then finally build a redstone circuit that properly reads the model from memory, executes it and stores the result back in memory.&lt;/p&gt;

&lt;p&gt;However, this was a hell lot more tedious than I initially imagined. The design of memory wasn’t fully scalable, this would mean that users would need to rewire the memory to CPU which isn’t exactly nice considering design principles. But most importantly, the FPU or CPU just wasn’t fast enough. Each operation on that CPU or FPU took about 1.5-2s to calculate on my decently fast CPU. This was obvious due to limited in-game capabilities. Note when I rant about 1.5-2s for computing answer using the FPU, it’s only in context of neural networks because they have thousands of these operations. From an electrical engineering standpoint, the &lt;a href=&quot;https://www.youtube.com/watch?v=5Fwy4jUJUoM&quot;&gt;FPU&lt;/a&gt; I am referring to is very elegantly designed.&lt;/p&gt;

&lt;p&gt;So after this I thought of quantization of neural network weights to use less bits to represent each number in weights and activations of the nerual net. Better yet, I opted for &lt;a href=&quot;https://arxiv.org/abs/1602.02830&quot;&gt;binarized neural networks&lt;/a&gt;. These use only a single bit for representing every number in computation of neural networks. Because of this, multiplication and addition operations become a lot easier.&lt;/p&gt;

&lt;h3 id=&quot;binarized-multiplication&quot;&gt;Binarized Multiplication&lt;/h3&gt;
&lt;p&gt;Following table describes the multiplication of 2 weights or activations when binarized to +1 or -1.&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;$$A$$&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;$$B$$&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;$$C = A * B$$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;!--
| $$A$$| $$B$$  | $$C = A * B$$ |
| :---: | :---: | :---------: |
| -1 | -1 | 1         |
| -1 | 1  | -1        |
| 1  | -1 |  -1       |
| 1  | 1  | 1         |
--&gt;

&lt;p&gt;In bit representation, this multiplication resembles XNOR gate.&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;$$A$$&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;$$B$$&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;$$C = A * B$$&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;$$C =\overline{A \oplus B}$$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;!--
| $$A$$  | $$B$$  | $$C = A * B$$ | $$C = \overline{A \oplus B}$$ |
| :---: | :---: | :---------: | :---: |
| 0 | 0 | 1         | 1 |
| 0 | 1  | 0        | 0 |
| 1  | 0 |  0       | 0 |
| 1  | 1  | 1         | 1 |
--&gt;

&lt;p&gt;This means that, in BNNs multiplication operation reduces to simple XNOR as opposed to &lt;a href=&quot;https://en.wikipedia.org/wiki/Floating-point_arithmetic#Multiplication_and_division&quot;&gt;complicated floating point multiplication algorithm&lt;/a&gt;. We can do XNOR operation in Minecraft as follows: (based on &lt;a href=&quot;https://www.youtube.com/watch?v=DR9BwuaPPH4&quot;&gt;this very compact design&lt;/a&gt;)&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;/files/blog_assets/neural-nets-in-minecraft/redstone-xnor-minecraft.png&quot; alt=&quot;redstone xnor minecraft&quot; width=&quot;100%&quot; /&gt;
&lt;/center&gt;

&lt;h3 id=&quot;binarized-reduceaddition&quot;&gt;Binarized Reduce/Addition&lt;/h3&gt;
&lt;p&gt;Reduce operation typically refers to adding up all elements of a tensor along some specific direction. In case of BNNs, since all the operands are either +1 or -1, we only need sign of the answer as the output of reduction operation. In bit representation, this translates to bitcounting operation. Therefore, to reduce a vector of length \(l\) of 1s and 0s, we only need to count number of 1s in the vector in some variable say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bitcount&lt;/code&gt;. Then, output of reduction operation is bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; (+1) if \((bitcount \geq l/2)\) and bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;(-1) otherwise.&lt;/p&gt;

&lt;p&gt;I couldn’t find a Minecraft version of this so I decided to design my own as follows:&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;/files/blog_assets/neural-nets-in-minecraft/redstone-reducer-minecraft.png&quot; alt=&quot;redstone reducer minecraft&quot; width=&quot;100%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;This reducer architecture unfortunately &lt;strong&gt;cannot work for more than 16 bits&lt;/strong&gt;. That being said I’m not a big redstone guy and I can’t even make a 4x4 flush piston door without looking up a tutorial. Maybe someone with deeper understanding of redstone mechanics can do a much better job at this.&lt;/p&gt;

&lt;h2 id=&quot;scarpet---a-programming-language-in-minecraft&quot;&gt;Scarpet - A programming language &lt;em&gt;in&lt;/em&gt; Minecraft&lt;/h2&gt;
&lt;p&gt;While the reducer I designed will work for small neural networks (only 3x3 conv filters, not more than 16 in any dimension etc.), I wanted to support more general and bigger neural networks. Scarpet is an in-game, functional-like programming language developed by &lt;a href=&quot;https://github.com/gnembon&quot;&gt;gnembon&lt;/a&gt;. While scarpet requires &lt;a href=&quot;https://github.com/gnembon/fabric-carpet&quot;&gt;carpetmod&lt;/a&gt; (which means our neural networks won’t be pure vanilla Minecraft-y), it is an excellent choice for building neural nets because it is server friendly and has a nifty &lt;a href=&quot;https://github.com/gnembon/fabric-carpet/blob/master/docs/scarpet/Full.md#game_tickmstime&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;game_tick()&lt;/code&gt;&lt;/a&gt; function. &lt;a href=&quot;https://github.com/gnembon/fabric-carpet/blob/master/docs/scarpet/Full.md#game_tickmstime&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;game_tick()&lt;/code&gt;&lt;/a&gt; allows you to essentially pause the game for specified amount of time. This means our block by block visualization requirement is also fulfilled. &lt;a href=&quot;https://github.com/ashutoshbsathe&quot;&gt;gnembon&lt;/a&gt; does an excellent job at explaining the language with the &lt;a href=&quot;https://github.com/gnembon/fabric-carpet/blob/master/docs/scarpet/Full.md&quot;&gt;documentation of scarpet&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;representation-of-neural-nets&quot;&gt;Representation of Neural Nets&lt;/h2&gt;
&lt;p&gt;With scarpet as our tool, we need to focus on representating binarized neural networks in Minecraft. We can set 2 different blocks for representing \(+1\) and \(-1\) in weights/activations. Moreover, I also thought it would be nice to be able to convert my PyTorch binarized neural network into my Minecraft representation. Therefore, I decided to generate a &lt;a href=&quot;https://github.com/maruohon/litematica&quot;&gt;litematica&lt;/a&gt; schematic for every layer of my neural network. Litematica allows you to put a schematic of block arrangements anywhere in the world, this schematic is extremely handy to recreate the block arrangement in the world.&lt;/p&gt;

&lt;p&gt;This means we need a program that can take in our PyTorch model and output a litematica schematic (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.litematica&lt;/code&gt; file) for every layer for us to build in our world. Unfortunately, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.litematica&lt;/code&gt; format isn’t very well documented. Thankfully with the help of the developer &lt;a href=&quot;https://github.com/maruohon&quot;&gt;maruohon&lt;/a&gt; and the &lt;a href=&quot;https://pypi.org/project/nbtlib/&quot;&gt;NBT data exploration library&lt;/a&gt; I was able to write to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.litematica&lt;/code&gt; file properly. The code for this module is available in the &lt;a href=&quot;https://github.com/ashutoshbsathe/scarpet-nn/tree/master/nn-to-litematica&quot;&gt;nn-to-litematica&lt;/a&gt; folder on my &lt;a href=&quot;https://github.com/ashutoshbsathe/scarpet-nn&quot;&gt;scarpet-nn&lt;/a&gt; repo. (note that &lt;a href=&quot;https://github.com/ashutoshbsathe/scarpet-nn/tree/master/nn-to-litematica&quot;&gt;nn-to-litematica&lt;/a&gt; currently supports only conv and fc layers without bias)&lt;/p&gt;

&lt;p&gt;I have written more about the litematica schematic generation rules in the &lt;a href=&quot;https://ashutoshbsathe.github.io/scarpet-nn/nn-to-litematica/&quot;&gt;documentation of scarpet-nn&lt;/a&gt;. With this much progress, it was just a matter of time to write some neat, modularized code for scarpet apps that implement our intended functionality.&lt;/p&gt;

&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;
&lt;p&gt;After fixing up a representation, I was able to build and run the neural network in my Minecraft world. But it was extremely boring to modify input block by block. To solve this, I decided to write a scarpet app called &lt;a href=&quot;https://github.com/ashutoshbsathe/scarpet-nn/blob/master/scarpet-apps/drawingboard.sc&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;drawingboard&lt;/code&gt;&lt;/a&gt; that lets you draw at the input layer by right clicking on it with any sword. I implemented a small binary image classifier that could detect digits &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; from the &lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot;&gt;MNIST dataset&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;See the working classifier demo:&lt;/p&gt;
&lt;div class=&quot;yt-iframe-container&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/LVmOcAYbYdU&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot; class=&quot;yt-iframe-video&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;Block by block visualization&lt;/p&gt;
&lt;div class=&quot;yt-iframe-container&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/KEcUKpBTk8M&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot; class=&quot;yt-iframe-video&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;So this is where I end my blog. Feel free to reach me for suggestions/comments/questions/your own neural networks built in Minecraft. I would love to hear from you!&lt;/p&gt;</content><author><name></name></author><summary type="html">This blog explains my thoughts behind creation of my project called scarpet-nn which allows you to implement binarized neural nets in Minecraft.</summary></entry></feed>